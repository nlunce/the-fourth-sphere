[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "GPS Positioning: A Mathematical Perspective",
    "section": "",
    "text": "The Global Positioning System (GPS) is a satellite-based navigation system consisting of 24 satellites equipped with atomic clocks, orbiting the Earth at an altitude of 20,200 km. By measuring the travel time of signals transmitted from satellites to a receiver, GPS calculates the receiver’s position in three-dimensional space. Each signal defines a sphere with a radius equal to the distance traveled by the signal, and the receiver’s position is at the intersection of these spheres.\nTo determine an accurate position (x, y, z) and synchronize the receiver’s clock, at least four satellites are required. The system of nonlinear equations representing the sphere intersections can be formulated as:\n\nr_i(x, y, z, d) = \\sqrt{(x - A_i)^2 + (y - B_i)^2 + (z - C_i)^2} - c(t_i - d) = 0\n\nwhere d is a clock correction factor for the receiver. Solving this system reveals both the receiver’s coordinates and the corrected clock time.\nHowever, the system faces challenges due to:\n\nReceiver Clock Inaccuracy: Affordable GPS receivers lack the precision of satellite atomic clocks, necessitating the inclusion of d in the equations.\nIll-Conditioning: The system becomes sensitive to errors when satellites are clustered close together in the sky.\nEnvironmental Factors: Signal transmission speed is affected by atmospheric interference and obstacles, introducing further inaccuracies.\n\nTo address these challenges:\n\nNumerical Root-Finding Methods (e.g., Newton-Krylov, Gauss-Newton) iteratively solve the equations but can struggle with sensitivity to initial guesses and ill-conditioning.\nError Analysis evaluates the system’s sensitivity to input timing errors, quantified through the Error Magnification Factor (EMF), which assesses the impact of small changes in signal timing on positional accuracy.\n\nBy leveraging precise satellite positions and signal timing data, this system provides accurate navigation but requires advanced mathematical techniques to manage inherent nonlinearities and ensure robustness. This report focuses on exploring and solving the GPS positioning problem through numerical and analytical approaches, providing insights into accuracy, stability, and efficiency."
  },
  {
    "objectID": "index.html#overview",
    "href": "index.html#overview",
    "title": "GPS Positioning: A Mathematical Perspective",
    "section": "",
    "text": "The Global Positioning System (GPS) is a satellite-based navigation system consisting of 24 satellites equipped with atomic clocks, orbiting the Earth at an altitude of 20,200 km. By measuring the travel time of signals transmitted from satellites to a receiver, GPS calculates the receiver’s position in three-dimensional space. Each signal defines a sphere with a radius equal to the distance traveled by the signal, and the receiver’s position is at the intersection of these spheres.\nTo determine an accurate position (x, y, z) and synchronize the receiver’s clock, at least four satellites are required. The system of nonlinear equations representing the sphere intersections can be formulated as:\n\nr_i(x, y, z, d) = \\sqrt{(x - A_i)^2 + (y - B_i)^2 + (z - C_i)^2} - c(t_i - d) = 0\n\nwhere d is a clock correction factor for the receiver. Solving this system reveals both the receiver’s coordinates and the corrected clock time.\nHowever, the system faces challenges due to:\n\nReceiver Clock Inaccuracy: Affordable GPS receivers lack the precision of satellite atomic clocks, necessitating the inclusion of d in the equations.\nIll-Conditioning: The system becomes sensitive to errors when satellites are clustered close together in the sky.\nEnvironmental Factors: Signal transmission speed is affected by atmospheric interference and obstacles, introducing further inaccuracies.\n\nTo address these challenges:\n\nNumerical Root-Finding Methods (e.g., Newton-Krylov, Gauss-Newton) iteratively solve the equations but can struggle with sensitivity to initial guesses and ill-conditioning.\nError Analysis evaluates the system’s sensitivity to input timing errors, quantified through the Error Magnification Factor (EMF), which assesses the impact of small changes in signal timing on positional accuracy.\n\nBy leveraging precise satellite positions and signal timing data, this system provides accurate navigation but requires advanced mathematical techniques to manage inherent nonlinearities and ensure robustness. This report focuses on exploring and solving the GPS positioning problem through numerical and analytical approaches, providing insights into accuracy, stability, and efficiency."
  },
  {
    "objectID": "index.html#objective",
    "href": "index.html#objective",
    "title": "GPS Positioning: A Mathematical Perspective",
    "section": "1.1 Objective",
    "text": "1.1 Objective\nThe objective of this study is to calculate the position of a GPS receiver (x, y, z) and correct the receiver’s clock bias d by solving a system of nonlinear equations. These equations model the distance between the receiver and multiple satellites based on signal travel times. The numerical solution relies on iterative root-finding methods to achieve high accuracy."
  },
  {
    "objectID": "index.html#background",
    "href": "index.html#background",
    "title": "GPS Positioning: A Mathematical Perspective",
    "section": "1.2 Background",
    "text": "1.2 Background\nIn a GPS system, the position of a receiver is determined by measuring the time it takes for signals to travel from multiple satellites. The propagation time, when multiplied by the speed of light c, provides the distance between the satellite and the receiver. Mathematically, the relationship between the receiver’s unknown position (x, y, z) and the clock correction d is expressed as a system of nonlinear equations:\n\n\\sqrt{(x - A_i)^2 + (y - B_i)^2 + (z - C_i)^2} = c(t_i - d), \\quad i = 1, 2, 3, 4\n\nWhere:\n\n(A_i, B_i, C_i) are the known satellite positions.\nt_i are the measured signal travel times.\nc \\approx 299,792.458 \\, \\text{km/s} is the speed of light.\n(x, y, z) are the unknown receiver coordinates.\nd is the receiver clock correction.\n\nEach equation corresponds to a sphere centered at the satellite’s position, with the radius equal to the computed distance. The receiver’s position lies at the intersection of these spheres. The inclusion of d accounts for the clock bias in the receiver, which is less precise than the atomic clocks onboard GPS satellites."
  },
  {
    "objectID": "index.html#methodology",
    "href": "index.html#methodology",
    "title": "GPS Positioning: A Mathematical Perspective",
    "section": "1.3 Methodology",
    "text": "1.3 Methodology\nA numerical root-finding approach is employed to solve this system of nonlinear equations. Specifically, Python’s fsolve function from the scipy.optimize library is utilized. This method iteratively refines estimates for (x, y, z, d) until the residuals—the differences between the measured and calculated distances—are minimized.\n\n1.3.1 Formulation of the Problem\nThe system of equations is reformulated as residual functions f_i, where each function evaluates to zero when the system is satisfied:\n\nf_i(x, y, z, d) = \\sqrt{(x - A_i)^2 + (y - B_i)^2 + (z - C_i)^2} - c(t_i - d), \\quad i = 1, 2, 3, 4\n\nThe root-finding process involves solving for (x, y, z, d) such that all f_i(x, y, z, d) = 0.\n\n\n1.3.2 Numerical Solution\nThe computational steps are as follows:\n\nInput Data: Known satellite positions (A_i, B_i, C_i) and signal travel times t_i are provided as inputs, along with the speed of light c.\nInitial Guess: A starting point of (x_0, y_0, z_0) = (0, 0, 6370) km is assumed, placing the receiver near the Earth’s surface. The initial clock correction is set to d_0 = 0.\nIterative Solver: The fsolve function iteratively adjusts (x, y, z, d) to minimize the residuals f_i. The algorithm terminates when all residuals approach zero, indicating convergence to a solution.\n\nThe implementation was tested using the following dataset:\n\nSatellite positions:\n\n(15,600, 7,540, 20,140)\n(18,760, 2,750, 18,610)\n(17,610, 14,630, 13,480)\n(19,170, 610, 18,390)\n\nSignal travel times: \nt = [0.07074, 0.07220, 0.07690, 0.07242] \\, \\text{(in seconds)}\n\n\n\n\n\n\n\n\nAccompanying Code\n\n\n\nThe accompanying code implementation defines the residual function, applies the fsolve solver, and outputs the computed results."
  },
  {
    "objectID": "index.html#results",
    "href": "index.html#results",
    "title": "GPS Positioning: A Mathematical Perspective",
    "section": "1.4 Results",
    "text": "1.4 Results\nThe numerical root-finding method produced the following results:\n\nReceiver Position (in km): \n(x, y, z) = (-41.77271, -16.78919, 6370.0596)\n\nClock Correction (in seconds): \nd = -3.201566 \\times 10^{-3}\n\n\nThese values were verified against expected results, confirming the accuracy of the numerical solution. The computed receiver position aligns with the Earth’s surface, and the clock correction accounts for the slight bias in the receiver’s timing."
  },
  {
    "objectID": "index.html#limitations",
    "href": "index.html#limitations",
    "title": "GPS Positioning: A Mathematical Perspective",
    "section": "1.5 Limitations",
    "text": "1.5 Limitations\nWhile the numerical root-finding approach proved effective, several limitations should be noted:\n\nSensitivity to Ill-Conditioning: The system may become ill-conditioned when satellite positions are clustered, amplifying numerical errors and reducing accuracy.\nDependence on Initial Guesses: Poor initial guesses can lead to non-convergence or convergence to an incorrect solution.\nComputational Cost: Iterative methods like fsolve require multiple evaluations of the residuals, making them computationally expensive for real-time applications.\nLack of Analytical Insights: The numerical solution provides no explicit relationships between the variables, limiting its use for sensitivity analysis or theoretical exploration."
  },
  {
    "objectID": "index.html#motivation-for-an-improved-approach",
    "href": "index.html#motivation-for-an-improved-approach",
    "title": "GPS Positioning: A Mathematical Perspective",
    "section": "1.6 Motivation for an Improved Approach",
    "text": "1.6 Motivation for an Improved Approach\nThe limitations of the numerical root-finding method highlight the need for a more robust and efficient solution. Specifically:\n\nA method that avoids iterative guesswork.\nImproved handling of ill-conditioned systems.\nA more analytical approach that isolates variables and reduces the problem complexity.\n\nTo address these concerns, the next section introduces a determinant-based analytical approach. This method linearizes the system of equations, isolates variables explicitly, and reduces the problem to solving a single quadratic equation for the clock correction d. It offers both computational efficiency and greater stability, making it well-suited for real-time GPS positioning."
  },
  {
    "objectID": "index.html#conclusion",
    "href": "index.html#conclusion",
    "title": "GPS Positioning: A Mathematical Perspective",
    "section": "1.7 Conclusion",
    "text": "1.7 Conclusion\nThe numerical root-finding approach provides an approximate solution to the GPS equations but is limited by its sensitivity, inefficiency, and lack of robustness. These shortcomings motivate the need for an improved analytical method, which will be explored in the following section."
  },
  {
    "objectID": "index.html#objective-1",
    "href": "index.html#objective-1",
    "title": "GPS Positioning: A Mathematical Perspective",
    "section": "2.1 Objective",
    "text": "2.1 Objective\nThe objective of this section is to solve the GPS equations analytically using a determinant-based approach. Unlike numerical root-finding methods, this analytical technique avoids iterative guesswork by isolating the variables (x, y, z, d) explicitly. By systematically transforming the original nonlinear system into a more manageable linear form, this method ensures greater robustness, stability, and computational efficiency—critical for real-time or precision GPS applications.\nThe approach has been implemented in Python using the SymPy library to symbolically manipulate the equations, solve the system, and isolate the unknowns step-by-step."
  },
  {
    "objectID": "index.html#problem-formulation",
    "href": "index.html#problem-formulation",
    "title": "GPS Positioning: A Mathematical Perspective",
    "section": "2.2 Problem Formulation",
    "text": "2.2 Problem Formulation\nThe GPS receiver’s position (x, y, z) and clock offset d are determined from four satellite equations of the form:\n\n\\sqrt{(x - A_i)^2 + (y - B_i)^2 + (z - C_i)^2} = c(t_i - d), \\quad i = 1, 2, 3, 4\n\nHere:\n\n(A_i, B_i, C_i) are known satellite coordinates.\nt_i are measured signal travel times.\nc \\approx 299792.458\\,\\text{km/s} is the speed of light.\n(x, y, z) and d are the unknown receiver coordinates and clock correction.\n\nEach equation represents a sphere with the satellite at its center. The receiver lies at the intersection of these four spheres. However, the presence of square roots and the unknown d makes the system inherently nonlinear and challenging to solve directly."
  },
  {
    "objectID": "index.html#methodology-1",
    "href": "index.html#methodology-1",
    "title": "GPS Positioning: A Mathematical Perspective",
    "section": "2.3 Methodology",
    "text": "2.3 Methodology\n\n\n\n\n\n\nCode Implementation\n\n\n\nThe solution process involves three key stages, all of which are implemented in the accompanying Python code.\n\n\n\n2.3.1 Reducing the Nonlinear System to a Linear Form\nTo eliminate the square roots, we square each equation. After doing so, we have:\n\n(x - A_i)^2 + (y - B_i)^2 + (z - C_i)^2 = c^2(t_i - d)^2\n\nWe then subtract the equations for satellites i=2,3,4 from the equation for i=1. This subtraction removes the x^2 + y^2 + z^2 terms and results in three linear equations in the four unknowns x, y, z, d:\n\nx u_{x}^{(j)} + y u_{y}^{(j)} + z u_{z}^{(j)} + d u_{d}^{(j)} + w^{(j)} = 0,\\quad j=1,2,3\n\nwhere u_x^{(j)}, u_y^{(j)}, u_z^{(j)}, u_d^{(j)}, w^{(j)} are constants determined by the satellite positions and travel times.\nAt this point, we have three linear equations with four unknowns:\n\nx u_{x1} + y u_{y1} + z u_{z1} + d u_{d1} + w_1 = 0\n\n\nx u_{x2} + y u_{y2} + z u_{z2} + d u_{d2} + w_2 = 0\n\n\nx u_{x3} + y u_{y3} + z u_{z3} + d u_{d3} + w_3 = 0\n\n\n\n\n\n\n\nAccompanying Code\n\n\n\nIn the accompanying code, this system of equations is constructed symbolically using SymPy, with the simplify() function applied to ensure clarity and precision in the linearized expressions.\n\n\n\nWhy Solve for the Variables in Terms of d?\n\nWith three linear equations and four unknowns, the system is underdetermined. We cannot directly solve for all four variables at once. To proceed, we:\n\nTreat d as a parameter.\nExpress x, y, z as linear functions of d:\n\nx = f_x(d), \\quad y = f_y(d), \\quad z = f_z(d)\n\n\nOnce x, y, z are known in terms of d, we substitute these functions back into one of the original nonlinear equations. This will yield a single quadratic equation in d. Solving that quadratic equation gives us d. With d in hand, we easily find x, y, z.\nThis approach reduces the complexity: instead of trying to solve four nonlinear equations simultaneously, we simplify the problem to solving one quadratic equation after isolating variables in terms of d.\n\n\nIntroducing the Determinant Equation\n\nTo isolate x, y, z in terms of d, we use a determinant-based approach. Determinants are a powerful linear algebra tool. By arranging our linear equations in a matrix form and considering certain determinants, we can:\n\nIdentify linear dependencies,\nIsolate one variable at a time,\nAvoid ambiguity and instability.\n\nThe idea is to construct a determinant from the system of equations and carefully manipulate it so that one variable (e.g., x) can be extracted in terms of y, z, d and constants. We then repeat or apply a similar reasoning for y and z.\n\n\n\n2.3.2 Isolating x in Terms of d Using the Determinant\nStep-by-Step for x:\n\nSet Up the Determinant:\nConsider a matrix formed from the coefficient vectors \\mathbf{u_x}, \\mathbf{u_y}, \\mathbf{u_z}, \\mathbf{u_d}, \\mathbf{w}. A key construction is:\n\n\\det[\\mathbf{u_y} \\mid \\mathbf{u_z} \\mid x\\mathbf{u_x} + y\\mathbf{u_y} + z\\mathbf{u_z} + d\\mathbf{u_d} + \\mathbf{w}] = 0\n\nThis determinant equals zero because if -\\mathbf{w} lies in the span of the other vectors, the system is consistent. Expanding this determinant along the third column will separate terms involving x, y, z, d.\n\n\\text{det} \\begin{bmatrix}\nu_{y1} & u_{z1} & x u_{x1} + y u_{y1} + z u_{z1} + d u_{d1} + w_1 \\\\\nu_{y2} & u_{z2} & x u_{x2} + y u_{y2} + z u_{z2} + d u_{d2} + w_2 \\\\\nu_{y3} & u_{z3} & x u_{x3} + y u_{y3} + z u_{z3} + d u_{d3} + w_3\n\\end{bmatrix} = 0\n\nExpand the Determinant:\nExpanding along the third column gives:\n\n\\text{det}[\\dots] = (x u_{x1} + y u_{y1} + z u_{z1} + d u_{d1} + w_1) \\cdot \\text{det} \\begin{bmatrix}\nu_{y2} & u_{z2} \\\\\nu_{y3} & u_{z3}\n\\end{bmatrix}\n\n\n- (x u_{x2} + y u_{y2} + z u_{z2} + d u_{d2} + w_2) \\cdot \\text{det} \\begin{bmatrix}\nu_{y1} & u_{z1} \\\\\nu_{y3} & u_{z3}\n\\end{bmatrix}\n\n\n+ (x u_{x3} + y u_{y3} + z u_{z3} + d u_{d3} + w_3) \\cdot \\text{det} \\begin{bmatrix}\nu_{y1} & u_{z1} \\\\\nu_{y2} & u_{z2}\n\\end{bmatrix}\n\nGroup Terms Involving x, y, z, d:\nCollect coefficients for each variable. For example for x, the coefficient C_x is:\n\nC_x = u_{x1} \\cdot \\text{det} \\begin{bmatrix}\nu_{y2} & u_{z2} \\\\\nu_{y3} & u_{z3}\n\\end{bmatrix}\n- u_{x2} \\cdot \\text{det} \\begin{bmatrix}\nu_{y1} & u_{z1} \\\\\nu_{y3} & u_{z3}\n\\end{bmatrix}\n+ u_{x3} \\cdot \\text{det} \\begin{bmatrix}\nu_{y1} & u_{z1} \\\\\nu_{y2} & u_{z2}\n\\end{bmatrix}\n\nOn expansion, you get an equation of the form:\n\nC_x x + C_y y + C_z z + C_d d + T = 0\n\nwhere C_x, C_y, C_z, C_d, T are combinations of determinants and known constants derived from the satellite data.\nIsolate x:\nTo solve for x, rearrange the equation:\n\nx = -\\frac{C_y y + C_z z + C_d d + T}{C_x}\n\nHowever, at this stage, x is still expressed in terms of y, z, d. To get x purely in terms of d, you must similarly isolate y and z in terms of d.\nRepeat for y and z:\nBy constructing similar determinant equations and performing analogous expansions, you isolate y and z as linear functions of d:\n\ny = f_y(d), \\quad z = f_z(d)\n\nOnce y(d) and z(d) are known, substitute them back into the expression for x:\n\nx = f_x(d)\n\nNow all three spatial variables are functions of d:\n\nx = f_x(d), \\quad y = f_y(d), \\quad z = f_z(d)\n\n\n\n\n\n\n\n\nAccompanying Code\n\n\n\nThe accompanying code uses SymPy’s linear_eq_to_matrix to extract the coefficient matrix and split it into parts:\n\nA_{xyz}: Coefficients for x, y, z,\nA_d: Coefficients for d.\n\nThe resulting system is:\n\nA\\_{xyz} \\begin{bmatrix} x \\\\ y \\\\ z \\end{bmatrix} = -A_d d - \\mathbf{w}.\n\nSolving this system for x, y, and z in terms of d is achieved using the LUsolve function. The symbolic solutions x(d), y(d), and z(d) are simplified and stored.\n\n\n\n\n2.3.3 Forming the Quadratic Equation in d\nWith x(d), y(d), z(d) established, we return to an original nonlinear equation. For example:\n\n\\sqrt{(x - A_1)^2 + (y - B_1)^2 + (z - C_1)^2} = c(t_1 - d)\n\n\nSubstitute x(d), y(d), z(d) into the left-hand side.\nSquare both sides to remove the square root.\n\nAfter simplification, you obtain a quadratic equation in d:\n\na d^2 + b d + c = 0\n\nSolving this quadratic equation using the quadratic formula:\n\nd = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}\n\nChoose the physically meaningful solution for d (the one placing the receiver near Earth’s surface), then substitute d back into x(d), y(d), z(d) to find the final coordinates (x, y, z).\n\n\n\n\n\n\nAccompanying Code\n\n\n\n\nOnce x(d), y(d), and z(d) are known, they are substituted back into one of the original nonlinear equations (e.g., the first equation). This substitution is performed symbolically in the code using subs().\nSimplifying the resulting equation produces a quadratic equation in d:\n\n\na d^2 + b d + c = 0.\n\n\nThe coefficients of the quadratic equation are extracted using SymPy’s Poly and all_coeffs functions. The quadratic formula is then applied to solve for d.\nAmong the solutions for d, the physically meaningful (real and close to zero) solution is selected. This step is automated in the code by evaluating the solutions and filtering for real roots.\nThe final values of x, y, and z are computed by substituting the selected d back into x(d), y(d), and z(d).\n\nResults\nThe determinant-based analytical approach produces the following results:\n\nReceiver Position (in km): \n(x, y, z) = (-41.77271, -16.78919, 6370.0596)\n\nClock Correction (in seconds): \nd = -3.201566 \\times 10^{-3}.\n\n\nThese results are consistent with the numerical solutions obtained in numerical root-finding approach, confirming the correctness of the analytical method."
  },
  {
    "objectID": "index.html#conclusion-1",
    "href": "index.html#conclusion-1",
    "title": "GPS Positioning: A Mathematical Perspective",
    "section": "2.4 Conclusion",
    "text": "2.4 Conclusion\nThis determinant-based analytical approach transforms the original nonlinear GPS equations into a linearized problem, uses determinants to isolate x, y, z in terms of d, and ultimately reduces the entire system to solving a single quadratic equation in d.\nKey Advantages:\n\nNo iterative guesswork required, avoiding convergence issues.\nMore stable and robust, especially when satellites are poorly distributed.\nProvides a closed-form, analytical solution, offering deeper insight and efficiency.\n\nBy following these steps—reducing to a linear system, isolating variables in terms of d using determinants, and forming a single quadratic in d—we obtain a direct and reliable solution to the GPS positioning problem."
  },
  {
    "objectID": "index.html#objective-2",
    "href": "index.html#objective-2",
    "title": "GPS Positioning: A Mathematical Perspective",
    "section": "3.1 Objective",
    "text": "3.1 Objective\nThe objective of this section is to evaluate how the conditioning of the GPS system changes when the satellite positions are either loosely distributed or tightly grouped. Sensitivity to small errors in signal travel times t_i is analyzed using the Error Magnification Factor (EMF). By comparing EMF values for both configurations, we identify how satellite geometry impacts the robustness and stability of the GPS positioning system."
  },
  {
    "objectID": "index.html#background-1",
    "href": "index.html#background-1",
    "title": "GPS Positioning: A Mathematical Perspective",
    "section": "3.2 Background",
    "text": "3.2 Background\n\n3.2.1 GPS Sensitivity and Conditioning\nIn GPS systems, small timing errors \\Delta t_i in the satellite signals can result in significant positional errors. These errors arise from the ill-conditioning of the system of equations, which occurs when satellite positions are geometrically clustered.\nThe system is analyzed by:\n\nIntroducing Perturbations: A small timing error \\Delta t_i \\approx 10^{-8} \\, \\text{s} (equivalent to 3 \\, \\text{meters}) is applied to each signal.\nForward Error: The resulting change in the computed position is measured as: \n\\|\\Delta x, \\Delta y, \\Delta z\\|_2 = \\sqrt{(\\Delta x)^2 + (\\Delta y)^2 + (\\Delta z)^2}\n\nError Magnification Factor (EMF): The EMF quantifies the sensitivity of the system to perturbations: \n\\text{EMF} = \\frac{\\|\\Delta x, \\Delta y, \\Delta z\\|_2}{c \\, \\|\\Delta t_i\\|_2}\n A higher EMF indicates a poorly conditioned system.\n\n\n\n3.2.2 Satellite Geometry\n\nLoosely Distributed Satellites: Satellites are widely spaced across the sky, providing better geometric diversity. This reduces ill-conditioning and improves robustness.\nTightly Grouped Satellites: Satellites are close together (within 5% of one another in spherical coordinates), leading to geometric correlation and increased sensitivity to timing errors."
  },
  {
    "objectID": "index.html#methodology-2",
    "href": "index.html#methodology-2",
    "title": "GPS Positioning: A Mathematical Perspective",
    "section": "3.3 Methodology",
    "text": "3.3 Methodology\n\n3.3.1 Steps to Solve\nThe analysis was conducted as follows:\n\nSatellite Position Generation:\n\nLoosely distributed satellites were generated using diverse spherical coordinates (\\phi and \\theta).\nTightly grouped satellites were generated by restricting both \\phi_i and \\theta_i within 5% of one another.\n\nNominal and Perturbed Signal Times:\n\nFor both configurations, nominal signal travel times t_i were calculated based on the range: \nR_i = \\sqrt{A_i^2 + B_i^2 + (C_i - 6370)^2}, \\quad t_i = d + \\frac{R_i}{c}\n\nEach t_i was perturbed by 10^{-8} \\, \\text{s}, while other times were held constant.\n\nSolve for Position:\n\nThe GPS equations were solved numerically using fsolve for both nominal and perturbed travel times.\nThe positional error \\|\\Delta x, \\Delta y, \\Delta z\\|_2 was computed for each perturbation.\n\nCalculate EMF:\nThe EMF was calculated using the formula:\n\n\\text{EMF} = \\frac{\\|\\Delta x, \\Delta y, \\Delta z\\|_2}{c \\, \\|\\Delta t_i\\|_2}\n\nCompare Results:\nEMF values were compared for both the loosely distributed and tightly grouped satellite configurations.\n\n\n\n\n\n\n\nAccompanying Code\n\n\n\nThe accompanying code performs the following steps:\n\nGenerate Satellite Positions:\n\nLoosely spaced satellites use diverse \\phi and \\theta values.\nTightly grouped satellites have \\phi and \\theta within 5% of each other.\n\nCalculate Ranges and Times:\nNominal ranges R_i and travel times t_i are computed.\nIntroduce Perturbations:\nEach signal time t_i is perturbed by 10^{-8} \\, \\text{s}, and the GPS equations are solved numerically using fsolve.\nCompute Forward Error and EMF:\n\nThe positional error is computed as the Euclidean distance between the nominal and perturbed positions.\nEMF values are calculated for each perturbation.\n\nComparison of Configurations:\nEMF values for loosely and tightly grouped satellites are compared, and the maximum EMF is identified."
  },
  {
    "objectID": "index.html#results-1",
    "href": "index.html#results-1",
    "title": "GPS Positioning: A Mathematical Perspective",
    "section": "3.4 Results",
    "text": "3.4 Results\nThe results of the EMF analysis for both satellite configurations are as follows:\n\n3.4.1 Loose Satellites\n\n\n\nPerturbation in t_i\nEMF Value\n\n\n\n\nt_1\n2.207538\n\n\nt_2\n2.828432\n\n\nt_3\n2.856126\n\n\nt_4\n2.203932\n\n\n\nMaximum EMF:\n\n\\text{EMF}_{\\text{max}} = 2.856126\n\n\n\n3.4.2 Tightly Grouped Satellites\n\n\n\nPerturbation in t_i\nEMF Value\n\n\n\n\nt_1\n1553.480087\n\n\nt_2\n2317.787515\n\n\nt_3\n3402.498373\n\n\nt_4\n466.068303\n\n\n\nMaximum EMF:\n\n\\text{EMF}_{\\text{max}} = 3402.498373\n\n\n\n3.4.3 Comparison\n\n\n\nConfiguration\nEMF Range\nMaximum EMF\nSensitivity\n\n\n\n\nLoose Satellites\n2.2 to 2.8\n2.856126\nLow\n\n\nTightly Grouped\n466 to 3402\n3402.498373\nVery High"
  },
  {
    "objectID": "index.html#interpretation",
    "href": "index.html#interpretation",
    "title": "GPS Positioning: A Mathematical Perspective",
    "section": "3.5 Interpretation",
    "text": "3.5 Interpretation\nThe results demonstrate a clear relationship between satellite geometry and the conditioning of the GPS system:\n\nLoose Satellites:\n\nEMF values remain low (around 2–3), indicating that the system is well-conditioned.\nPerturbations in signal times result in small position errors due to the geometric diversity of the satellites.\n\nTightly Grouped Satellites:\n\nEMF values increase dramatically (up to 3402), showing that the system becomes ill-conditioned.\nSmall input errors are significantly amplified, leading to large position errors.\nThis sensitivity arises from the satellites’ correlated geometry, where their signals cannot provide sufficient independent information."
  },
  {
    "objectID": "index.html#conclusion-2",
    "href": "index.html#conclusion-2",
    "title": "GPS Positioning: A Mathematical Perspective",
    "section": "3.6 Conclusion",
    "text": "3.6 Conclusion\nThis analysis highlights the critical role of satellite geometry in the conditioning of the GPS system:\n\nLoosely distributed satellites provide better geometric diversity and robustness, resulting in lower EMF values and greater accuracy.\nTightly grouped satellites lead to poor conditioning, amplifying errors and making the system highly sensitive to small perturbations in signal travel times.\n\nTo ensure accurate and stable GPS positioning, it is essential to use satellites with diverse spatial distributions. This insight is particularly valuable for optimizing satellite selection algorithms in GPS receivers."
  },
  {
    "objectID": "code/index.html",
    "href": "code/index.html",
    "title": "Code",
    "section": "",
    "text": "#Import Libraries\nimport numpy as np\nfrom scipy.optimize import fsolve\nimport sympy as sp\n\n# -----------------------------------------------------\n# PROBLEM 1: Numerical Root-Finding for GPS Positioning\n# -----------------------------------------------------\n\n# Given constants and satellite data\nc = 299792.458  # Speed of light in km/s\nA = [15600, 18760, 17610, 19170]  # Satellite x-coordinates in km\nB = [7540, 2750, 14630, 610]      # Satellite y-coordinates in km\nC = [20140, 18610, 13480, 18390]  # Satellite z-coordinates in km\nt = [0.07074, 0.07220, 0.07690, 0.07242]  # Signal travel times in seconds\n\n# Function to define the residuals for the nonlinear system\ndef residuals(vars):\n    \"\"\"\n    Residual function for GPS equations:\n    sqrt((x - A_i)^2 + (y - B_i)^2 + (z - C_i)^2) - c * (t_i - d)\n    \"\"\"\n    x, y, z, d = vars  # Unpack the unknowns\n    res = []\n    for i in range(4):  # Loop through the 4 satellites\n        dist = np.sqrt((x - A[i])**2 + (y - B[i])**2 + (z - C[i])**2)\n        res.append(dist - c * (t[i] - d))  # Append each residual\n    return res\n\n# Initial guess for (x, y, z, d)\ninitial_guess = [0, 0, 6370.0, 0]  # Receiver near Earth's surface and d = 0\n\n# Solve the nonlinear system using fsolve\nsol = fsolve(residuals, initial_guess)\n\n# Print the solution for (x, y, z, d)\nprint(\"----- PROBLEM 1: Numerical Solution -----\")\nprint(f\"x = {sol[0]:.6f} km\")\nprint(f\"y = {sol[1]:.6f} km\")\nprint(f\"z = {sol[2]:.6f} km\")\nprint(f\"d = {sol[3]:.6e} seconds\")\nprint(\"-----------------------------------------\\n\")\n\n# ------------------------------------------------------------\n# PROBLEM 2: Determinant-Based Analytical Approach for GPS\n# ------------------------------------------------------------\n\n# Define symbolic variables\nx, y, z, d = sp.symbols('x y z d', real=True)\n\n# Formulate the nonlinear equations\neqs = []\nfor i in range(4):\n    eq = (x - A[i])**2 + (y - B[i])**2 + (z - C[i])**2 - (c * (t[i] - d))**2\n    eqs.append(eq)\n\n# Linearize the system\n# Subtract eqs[1], eqs[2], and eqs[3] from eqs[0] to eliminate x^2, y^2, z^2 terms\nlin_eqs = [sp.simplify(eqs[0] - eqs[i]) for i in range(1, 4)]\n\n# Extract the coefficients of the linear equations\nA_matrix, b_vector = sp.linear_eq_to_matrix(lin_eqs, [x, y, z, d])\n\n# Split the coefficient matrix into components:\nA_xyz = A_matrix[:, :3]  # Coefficients of x, y, z\nA_d = A_matrix[:, 3]     # Coefficient of d\n\n# Solve for x, y, z in terms of d\nxyz_solution = A_xyz.LUsolve(b_vector - A_d * d)\n\n# Simplify solutions for x, y, z as functions of d\nx_d = sp.simplify(xyz_solution[0])\ny_d = sp.simplify(xyz_solution[1])\nz_d = sp.simplify(xyz_solution[2])\n\n# Substitute x(d), y(d), z(d) into the first original equation\nquadratic_eq_d = sp.simplify(eqs[0].subs({x: x_d, y: y_d, z: z_d}))\n\n# Solve the resulting quadratic equation for d\ncoeffs_d = sp.Poly(quadratic_eq_d, d).all_coeffs()\nd_solutions = sp.solve(quadratic_eq_d, d)\n\n# Select the physically meaningful solution for d (real and close to zero)\nd_final = None\nfor candidate in d_solutions:\n    if candidate.is_real:\n        d_final = candidate.evalf()\n        break\n\n# Compute final (x, y, z) by substituting d into x_d, y_d, z_d\nx_final = x_d.subs(d, d_final).evalf()\ny_final = y_d.subs(d, d_final).evalf()\nz_final = z_d.subs(d, d_final).evalf()\n\n# Print the final analytical solution\nprint(\"----- PROBLEM 2: Analytical Solution -----\")\nprint(f\"x = {x_final:.6f} km\")\nprint(f\"y = {y_final:.6f} km\")\nprint(f\"z = {z_final:.6f} km\")\nprint(f\"d = {d_final:.6e} seconds\")\nprint(\"-----------------------------------------\")\n\n# ------------------------------------------------------------\n# PROBLEM 4 & 5: Conditioning Analysis of the GPS Problem\n# ------------------------------------------------------------\n\n# Constants\nc = 299792.458  # Speed of light in km/s\nrho = 26570  # Fixed satellite altitude in km\nreceiver_pos = np.array([0, 0, 6370])  # Receiver fixed at Earth's surface\nd_initial = 0.0001  # Initial clock bias\nperturbation = 1e-8  # Perturbation in seconds\n\n# Function to compute satellite positions in Cartesian coordinates\ndef compute_satellite_positions(phi, theta):\n    A = [rho * np.cos(p) * np.cos(t) for p, t in zip(phi, theta)]\n    B = [rho * np.cos(p) * np.sin(t) for p, t in zip(phi, theta)]\n    C = [rho * np.sin(p) for p in phi]\n    return np.array(A), np.array(B), np.array(C)\n\n# Compute nominal ranges and travel times\ndef compute_nominal_values(A, B, C):\n    R = np.sqrt((A - receiver_pos[0])**2 + (B - receiver_pos[1])**2 + (C - receiver_pos[2])**2)\n    t_nominal = d_initial + R / c\n    return R, t_nominal\n\n# GPS residual function\ndef gps_residuals(vars, t, A, B, C):\n    x, y, z, d = vars\n    residuals = np.sqrt((x - A)**2 + (y - B)**2 + (z - C)**2) - c * (t - d)\n    return residuals\n\n# EMF computation function\ndef compute_emf(t_perturbed, t_nominal, A, B, C):\n    initial_guess = [0, 0, 6370, d_initial]\n    sol_nominal = fsolve(gps_residuals, initial_guess, args=(t_nominal, A, B, C))\n    sol_perturbed = fsolve(gps_residuals, initial_guess, args=(t_perturbed, A, B, C))\n\n    position_error = np.linalg.norm(np.array(sol_perturbed[:3]) - np.array(sol_nominal[:3]))\n    input_error = np.linalg.norm(np.array(t_perturbed) - np.array(t_nominal)) * c\n    return position_error / input_error\n\n# Function to analyze EMF for given satellite configuration\ndef analyze_emf(phi, theta):\n    A, B, C = compute_satellite_positions(phi, theta)\n    _, t_nominal = compute_nominal_values(A, B, C)\n\n    emf_values = []\n    for i in range(4):\n        t_perturbed = t_nominal.copy()\n        t_perturbed[i] += perturbation\n        emf = compute_emf(t_perturbed, t_nominal, A, B, C)\n        emf_values.append(emf)\n\n    return emf_values\n\n# Loose satellite configuration\nphi_loose = [np.pi / 6, np.pi / 4, np.pi / 3, np.pi / 8]\ntheta_loose = [0, np.pi / 2, np.pi, 3 * np.pi / 2]\nemf_loose = analyze_emf(phi_loose, theta_loose)\n\n# Tightly grouped satellite configuration\ndef tightly_grouped_coordinates(phi_base, theta_base, perturb=0.05):\n    np.random.seed(42)  # For reproducibility\n    phi_tight = [phi_base * (1 + np.random.uniform(-perturb, perturb)) for _ in range(4)]\n    theta_tight = [theta_base * (1 + np.random.uniform(-perturb, perturb)) for _ in range(4)]\n    return phi_tight, theta_tight\n\nphi_base, theta_base = np.pi / 4, np.pi / 2\nphi_tight, theta_tight = tightly_grouped_coordinates(phi_base, theta_base)\nemf_tight = analyze_emf(phi_tight, theta_tight)\n\n# Print results\nprint(\"----- PROBLEM 4 & 5: CONDITIONING ANALYSIS COMPARISON -----\")\nprint(\"Loose Satellites:\")\nfor i, emf in enumerate(emf_loose):\n    print(f\"EMF for perturbation in t_{i+1}: {emf:.6f}\")\nprint(f\"Maximum EMF (Loose): {max(emf_loose):.6f}\\n\")\n\nprint(\"Tightly Grouped Satellites:\")\nfor i, emf in enumerate(emf_tight):\n    print(f\"EMF for perturbation in t_{i+1}: {emf:.6f}\")\nprint(f\"Maximum EMF (Tight): {max(emf_tight):.6f}\")\nprint(\"--------------------------------------------\")"
  }
]